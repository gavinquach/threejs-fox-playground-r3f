/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { Vector3, Quaternion } from "three";
import { useFrame } from "@react-three/fiber";

export default function Fox(props) {
    const { rigidBody, camera, orbitControl } = props;
    console.log(rigidBody.current);

    const group = useRef();
    const { nodes, materials, animations } = useGLTF('./models/Fox.glb');
    const { actions } = useAnimations(animations, group);

    const W = 'w';
    const A = 'a';
    const S = 's';
    const D = 'd';
    const DIRECTIONS = [W, A, S, D];

    const [model, setModel] = useState(null);
    let currentAction, playingAction;
    let cameraFollowRotation = 0;

    // state
    let toggleRun = false;

    // temporary data
    const walkDirection = new Vector3();
    const rotateAngle = new Vector3(0, 1, 0);
    const rotateQuarternion = new Quaternion();
    const cameraTarget = new Vector3();

    // constants
    const fadeDuration = 0.2;
    const runVelocity = 28;
    const walkVelocity = 15;
    const followCamHeight = 4;
    const followCamDistance = 6;


    // CONTROL KEYS
    const keysPressed = {};
    document.addEventListener('keydown', (event) => {
        if (event.shiftKey) {
            switchRunToggle();
        } else {
            (keysPressed)[event.key.toLowerCase()] = true;
        }
    }, false);
    document.addEventListener('keyup', (event) => {
        (keysPressed)[event.key.toLowerCase()] = false;
    }, false);

    useEffect(() => {
        setModel(group.current);

        // set idling anim as default
        currentAction = 'Survey';
        actions[currentAction].play();
        playingAction = currentAction;
    });

    useFrame((_, delta) => {
        updateCharacter(delta, keysPressed);
    });

    const switchRunToggle = () => {
        toggleRun = !toggleRun;
    };

    const updateCharacter = (delta, keysPressed) => {
        if (!model) return;

        const directionPressed = DIRECTIONS.some(key => keysPressed[key] == true);

        let toAction;
        if (directionPressed && toggleRun) {
            toAction = 'Run';
        } else if (directionPressed) {
            toAction = 'Walk';
        } else {
            toAction = 'Survey';
        }

        if (toAction && playingAction != toAction) {
            actions[currentAction].fadeOut(fadeDuration);
            playingAction = toAction;
            actions[playingAction].reset().fadeIn(fadeDuration).play();
            currentAction = playingAction;
        }

        if (currentAction == 'Run' || currentAction == 'Walk') {
            // calculate towards camera direction
            let angleYCameraDirection = Math.atan2(
                (camera.position.x - model.position.x),
                (camera.position.z - model.position.z));
            // diagonal movement angle offset
            let directionOffset = calculateDirectionOffset(keysPressed);

            // rotate model
            rotateQuarternion.setFromAxisAngle(rotateAngle, angleYCameraDirection + directionOffset);
            model.quaternion.rotateTowards(rotateQuarternion, 0.2);

            // calculate direction
            camera.getWorldDirection(walkDirection);
            walkDirection.y = 0;
            walkDirection.normalize();
            walkDirection.applyAxisAngle(rotateAngle, directionOffset);

            // run/walk velocity
            const velocity = currentAction == 'Run' ? runVelocity : walkVelocity;

            // move model & camera
            const moveX = -walkDirection.x * velocity * delta;
            const moveZ = -walkDirection.z * velocity * delta;
            model.position.x += moveX;
            model.position.z += moveZ;
            updateCameraTarget(moveX, moveZ);

            // rotate camera (in follow model mode)
            const rotateAng = Math.PI * 0.5 * delta * 1.5;

            if (keysPressed[A]) {
                cameraFollowRotation -= rotateAng;
            } else if (keysPressed[D]) {
                cameraFollowRotation += rotateAng;
            }

            const rotZ = Math.cos(cameraFollowRotation);
            const rotX = Math.sin(cameraFollowRotation);
            camera.position.x = model.position.x + (followCamDistance * rotX);
            camera.position.z = model.position.z - (followCamDistance * rotZ);
            camera.position.y = model.position.y + followCamHeight;
        }
    };

    const updateCameraTarget = (moveX, moveZ) => {
        // move camera
        camera.position.x += moveX;
        camera.position.z += moveZ;

        // update camera target
        cameraTarget.x = model.position.x;
        cameraTarget.y = model.position.y + 1;
        cameraTarget.z = model.position.z;
        orbitControl.target = cameraTarget;
    };

    const calculateDirectionOffset = (keysPressed) => {
        let directionOffset = 0; // s

        if (keysPressed[S]) {
            if (keysPressed[D]) {
                directionOffset = Math.PI * 0.25; // s + d
            } else if (keysPressed[A]) {
                directionOffset = - Math.PI * 0.25; // s + a
            }
        } else if (keysPressed[W]) {
            if (keysPressed[D]) {
                directionOffset = Math.PI * 0.25 + Math.PI * 0.5; // w + d
            } else if (keysPressed[A]) {
                directionOffset = -Math.PI * 0.25 - Math.PI * 0.5; // w + a
            } else {
                directionOffset = Math.PI; // w
            }
        } else if (keysPressed[D]) {
            directionOffset = Math.PI * 0.5; // d
        } else if (keysPressed[A]) {
            directionOffset = - Math.PI * 0.5; // a
        }

        return directionOffset;
    };

    return (
        <group ref={group} {...props} dispose={null}>
            <group name="root" scale={0.025}>
                <primitive object={nodes._rootJoint} />
                <skinnedMesh
                    name="fox"
                    geometry={nodes.fox.geometry}
                    material={materials.fox_material}
                    skeleton={nodes.fox.skeleton}
                />
            </group>
        </group>
    );
}

useGLTF.preload("./models/Fox.glb");
